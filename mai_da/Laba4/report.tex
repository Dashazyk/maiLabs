\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}



\begin{document}

\section*{Лабораторная работа №\,4 по курсу дискрeтного анализа: поиск образца в строке}

Выполнил студент группы М8О-208Б-17 МАИ \textit{Гринин Вячеслав}.

\subsection*{Условие}
Необходимо реализовать один из стандартных алгоритмов поиска образцов для указанного алфавита.\\
Алгоритм: Ахо-Корасик\\
Алфавит: Числа в диапазоне от $0$ до $2^32 - 1$\\

\subsection*{Метод решения}
Алгоритм Ахо-Корасик работает в несколько этапов:
\begin{enumerate}
	\item Получение образцов. Создание дерева бора. Дерево бора - то же префиксное дерево, только символы расположены на рёбрах.
	\item Конструирование конечного автомата Ахо-Корасик: обход дерева бора в ширину, установка суффиксных ссылок в узлах. Установка производится следующим образом:
	\begin{enumerate}
		\item Узел Б - дочерний узел. Узел А - узел-родитель. Запоминаем символ на ребре от А к Б. 
		\item Идём по суффиксной ссылке узла А. Ищем там ребро с тем же символом, которое ведёт в условный узел В. 
		\item Если нашли - устанавливаем суффиксную ссылку из узла Б на узел В. Иначе - поднимаемся по суффиксной ссылке дальше. Повторяем до тех пор, пока не встретим корень дерева или не наткнёмся на нужное ребро.
		\item Если полученная суффиксная ссылка указывает на терминирующий узел В - создаём отдельно терминальную ссылку, которая необходима для быстрого перечисления вхождений в тексте.
	\end{enumerate}
	\item После конструирования автомата можно начать пользоваться деревом. Идея передвижения по нему проста:
	\begin{enumerate}
		\item Получаем символ. Ищем ребро с этим символом. 
		\item Если нашли - идём по этому ребру.
		\item Иначе - идём по суффиксной ссылке. Пытаемся найти уже другое ребро с этим символом. Если нашли - идём по нему. Иначе - идём по суффиксной ссылке дальше.
		\item Повторять до попадания в корень или обнаружения нужного ребра с символом.
		\item Если оказалось, что узел терминальный - обнаружено вхождение.
		\item Если имеется терминальная ссылка - пробегаемся по ней. Распечатываем вхождения.
	\end{enumerate}
\end{enumerate}

\subsection*{Описание программы}

Программа делится на ряд файлов: main.cpp, TAhoCorasickNode.cpp, TAhoCorasickNode.h, TAhoCorasick.cpp, TAhoCorasick.h. 

Хедеры содержат определения классов и их методов.

\subsubsection*{TAhoCorasick.h}

Переменные-члены:
\begin{enumerate}
	\item TAKNode root - корень дерева бора;
	\item TAKNode* state - состояние машины;
	\item unsigned int size - число образцов в дереве;
	\item unsigned int lastStrNumb - номер строки, которую мы считываем в данный момент;
	\item std::vector<int> tableOfStr - динамический массив, запоминающий число символов отдельно в каждой строке;
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Приватные методы:
	\begin{enumerate}
		\item void Step(unsigned long long int) - отвечает за перемещение по дереву бора;
		\item void PrintTermsForCurrentState(unsigned int) const - выводит на экран все вхождения, которые имеются в данном состоянии.
	\end{enumerate}
	\item Публичные методы:
	\begin{enumerate}
		\item void EmptyStr() - уведомляет дерево о наличии пустой строки;
		\item void ToStart() - переход в корень;
		\item void FinPattern() - делает узел терминальным. Переход к следующему образцу;
		\item void AddToPattern(unsigned long long int) - добавление части образца в дерево;
		\item void Build() - создание конечной машины;
		\item void Search(unsigned long long int, unsigned int) - поиск образца в тексте по символу.
	\end{enumerate}
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TAhoCorasick() - задаёт начальное состояние как nullptr, выставляет size в ноль.
\end{enumerate}

Деструктор не имеется.

\subsubsection*{TAhoCorasickNode.h}

Переменные-члены:
\begin{enumerate}
	\item TLinksMap links - набор ребёр для данного узла, где TLinksMap - это std::map;
	\item TAKNode*  fail - суффиксная ссылка, где TAKNode - класс, являющийся узлом дерева бора;
	\item TAKNode*  term - терминальная ссылка;
	\item std::vector<int> numb - номера образцов, если узел терминальный;
	\item int deep - длина образца, если узел терминальный;
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Публичные методы:
	\begin{enumerate}
		\item void PushNumber(int) - задаёт номер образца;
		\item int GetCount() const - возвращает число идентичных образцов;
		\item TAKNode* GetLink(unsigned long long int) const - возвращает ссылку на узел, к которому можно добраться за счёт заданного символа;
		\item bool IsTerminal() const - проверяет, является ли узел терминальным.
	\end{enumerate}
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TAKNode() - задаёт ссылки, как nullptr, присваивает deep и out значения по умолчанию;
	\item TAKNode(TAKNode*) - аналогично конструктору выше. Только присваивает заданную суффиксную ссылку.
\end{enumerate}

Деструктор не имеется.

\subsection*{Дневник отладки}
10.04.19:\\
Не проходило первый тест - чекер ловил SIGSEGV, который, как позже оказалось, связан с тем, что переменная lastStrNumb не была проинициализирована в конструкторе;\\
Не проходило десятый тест - были случаи, когда вместо корректной позиции начала вхождения выводило на экран огромное значение. Злую шутку сыграла моя невнимательность и я зачем-то вместо обычного int написал unsigned int. Это и послужило причиной для подобного некорректного вывода позиции начала вхождения.

\subsection*{Тест производительности}
Тесты проходили таким образом. Генерируется заданное число образцов заданной длины, затем генерируется текст, по которому будет проходить алгоритм. Длина текста также предварительно задана пользователем. Текст и образцы генерируются полностью рандомно. В случайных местах текста генерируются образцы, чтобы алгоритм смог их распознать. Число образцов в тексте также рандомно. Далее составлялось дерево бора и строился конечный детерминированный автомат. Создание автомата и поиск производились 10 раз и бралось среднее арифметическое значение затраченного времени. Ради большей точности был выключен вывод вхождений на экран. Результаты вышли такие:
\begin{enumerate}
	\item Длина текста 1000, длина образцов 25, число образцов 10. Время: $0.000451$ секунд;
	\item Длина текста 10000, длина образцов 25, число образцов 10. Время: $0.0015498$ секунд;
	\item Длина текста 100000, длина образцов 25, число образцов 10. Время: $0.0134455$ секунд;
	\item Длина текста 1000, длина образцов 50, число образцов 10. Время: $0.0004396$ секунд;
	\item Длина текста 10000, длина образцов 50, число образцов 10. Время: $0.0016798$ секунд;
	\item Длина текста 100000, длина образцов 50, число образцов 10. Время: $0.0130634$ секунд;
	\item Длина текста 1000, длина образцов 100, число образцов 10. Время: $0.0007419$ секунд;
	\item Длина текста 10000, длина образцов 100, число образцов 10. Время: $0.002044$ секунд;
	\item Длина текста 100000, длина образцов 100, число образцов 10. Время: $0.0132732$ секунд;
	
	\item Длина текста 1000, длина образцов 25, число образцов 100. Время: $0.0021874$ секунд;
	\item Длина текста 10000, длина образцов 25, число образцов 100. Время: $0.0036718$ секунд;
	\item Длина текста 100000, длина образцов 25, число образцов 100. Время: $0.0165545$ секунд;
	\item Длина текста 1000, длина образцов 50, число образцов 100. Время: $0.004236$ секунд;
	\item Длина текста 10000, длина образцов 50, число образцов 100. Время: $0.0053569$ секунд;
	\item Длина текста 100000, длина образцов 50, число образцов 100. Время: $0.0177836$ секунд;
	\item Длина текста 1000, длина образцов 100, число образцов 100. Время: $0.0080602$ секунд;
	\item Длина текста 10000, длина образцов 100, число образцов 100. Время: $0.0094154$ секунд;
	\item Длина текста 100000, длина образцов 100, число образцов 100. Время: $0.021193$ секунд;
	
	\item Длина текста 1000, длина образцов 25, число образцов 1000. Время: $0.0277295$ секунд;
	\item Длина текста 10000, длина образцов 25, число образцов 1000. Время: $0.0290186$ секунд;
	\item Длина текста 100000, длина образцов 25, число образцов 1000. Время: $0.0413842$ секунд;
	\item Длина текста 1000, длина образцов 50, число образцов 1000. Время: $0.0592085$ секунд;
	\item Длина текста 10000, длина образцов 50, число образцов 1000. Время: $0.0499613$ секунд;
	\item Длина текста 100000, длина образцов 50, число образцов 1000. Время: $0.0633514$ секунд;
	\item Длина текста 1000, длина образцов 100, число образцов 1000. Время: $0.122093$ секунд;
	\item Длина текста 10000, длина образцов 100, число образцов 1000. Время: $0.102287$ секунд;
	\item Длина текста 100000, длина образцов 100, число образцов 1000. Время: $0.142306$ секунд;
\end{enumerate}

Преимущественно время работы зависит от длины текста и совокупной длины образцов. Это заметно если сравнить различные тесты с одинаковым числом образцов. Это особенно чувствуется когда их число достаточно больше. К слову размер алфавита - 1001 символ. А заявленная сложность алгоритма - $O((M + N)*log(k) + t)$, где $N$ - длина текста, в котором производится поиск, $M$ - общая длина всех слов в дереве бора, $k$ - размер алфавита, $t$ - общая длина всех совпадений. В нашем случае размер алфавита является константой - иначе таблица выше стала ещё больше. Так что можно опустить логарифм и получить сложность $O(M + N + t)$. В целом увиденные выше цифры совпадают с ожидаемой сложностью.

\subsection*{Выводы}

Данный алгоритм отлично себя проявляет, когда имеет дело со множеством образцов. Очевидно, что если в нём будет только один образец, то ничего путного не выйдет. Ведь смысл этого алгоритма состоит в том, чтобы находить множество образцов. Одна из особенностей этого алгоритма состоит в том, что он использует дерево бора, где символы расположены на рёбрах, а не на узлах. Это полезно в нашем случае, так как у нас имеется специальная структура map, которая обеспечивает поиск за $O(n*log(n))$. Так что поиск необходимого ребра достаточно быстр.

Пока искал информацию по алгоритму, узнал, что он применяется в утилите grep, которая выводит строки, в которых есть нужный образец. Да и в целом, когда у нас идёт речь о поиске нужной нам информации в куче файлов, да ещё эта информация ищется не по одному слову, а по нескольким, то алгоритм Ахо-Корасика позволит без особых проблем и затрат по времени найти её. К примеру, у нас есть огромный файл, который является энциклопедией про разных животных. Нам хочется найти информацию о птицах и земноводных. В таком случае мы заносим в дерево бора слова "Птица" и "Земноводное". И всё - строим конечную детерминированную машину и запускаем поиск.

Честно, после PATRICIA всё что угодно может казаться достаточно простым. Ахо-Корасик не показался чем-то совсем тяжёлым для понимания - подробное описание алгоритма можно найти во множестве статей на просторах Сети. Поэтому мне лично понять его было относительно просто. Единственная сложность - не сразу было понятно, как именно строятся суффиксные ссылки. А ведь это ключевая часть в понимании алгоритма как по мне.

\end{document}