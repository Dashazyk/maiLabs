\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}



\begin{document}

\section*{Лабораторная работа №\,4 по курсу дискрeтного анализа: поиск образца в строке}

Выполнил студент группы М8О-208Б-17 МАИ \textit{Гринин Вячеслав}.

\subsection*{Условие}
Необходимо реализовать один из стандартных алгоритмов поиска образцов для указанного алфавита.\\
Алгоритм: Ахо-Корасик\\
Алфавит: Числа в диапазоне от $0$ до $2^32 - 1$\\

\subsection*{Метод решения}
Алгоритм Ахо-Корасик работает в несколько этапов:
\begin{enumerate}
	\item Получение образцов. Создание дерева бора. Дерево бора - то же префиксное дерево, только символы расположены на рёбрах.
	\item Конструирование конечного автомата Ахо-Корасик: обход дерева бора в ширину, установка суффиксных ссылок в узлах. Установка производится следующим образом:
	\begin{enumerate}
		\item Узел Б - дочерний узел. Узел А - узел-родитель. Запоминаем символ на ребре от А к Б. 
		\item Идём по суффиксной ссылке узла А. Ищем там ребро с тем же символом, которое ведёт в условный узел В. 
		\item Если нашли - устанавливаем суффиксную ссылку из узла Б на узел В. Иначе - поднимаемся по суффиксной ссылке дальше. Повторяем до тех пор, пока не встретим корень дерева или не наткнёмся на нужное ребро.
		\item Если полученная суффиксная ссылка указывает на терминирующий узел В - создаём отдельно терминальную ссылку, которая необходима для быстрого перечисления вхождений в тексте.
	\end{enumerate}
	\item После конструирования автомата можно начать пользоваться деревом. Идея передвижения по нему проста:
	\begin{enumerate}
		\item Получаем символ. Ищем ребро с этим символом. 
		\item Если нашли - идём по этому ребру.
		\item Иначе - идём по суффиксной ссылке. Пытаемся найти уже другое ребро с этим символом. Если нашли - идём по нему. Иначе - идём по суффиксной ссылке дальше.
		\item Повторять до попадания в корень или обнаружения нужного ребра с символом.
		\item Если оказалось, что узел терминальный - обнаружено вхождение.
		\item Если имеется терминальная ссылка - пробегаемся по ней. Распечатываем вхождения.
	\end{enumerate}
\end{enumerate}

\subsection*{Описание программы}

Программа делится на ряд файлов: main.cpp, TAhoCorasickNode.cpp, TAhoCorasickNode.h, TAhoCorasick.cpp, TAhoCorasick.h. 

Хедеры содержат определения классов и их методов.

\subsubsection*{TAhoCorasick.h}

Переменные-члены:
\begin{enumerate}
	\item root - корень дерева бора;
	\item state - состояние машины;
	\item size - число образцов в дереве.
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Приватные методы:
	\begin{enumerate}
		\item Step(unsigned long long int) - отвечает за перемещение по дереву бора;
		\item PrintTermsForCurrentState(unsigned int, unsigned int) const - выводит на экран все вхождения, которые имются в данном состоянии.
	\end{enumerate}
	\item Публичные методы:
	\begin{enumerate}
		\item ToStart() - переход в корень;
		\item FinPattern() - делает узел терминальным. Переход к следующему образцу;
		\item AddToPattern(unsigned long long int) - добавление части образца в дерево;
		\item Build() - создание конечной машины;
		\item Search(unsigned long long int, unsigned int, unsigned int) - поиск образца в тексте по символу.
	\end{enumerate}
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TAhoCorasick() - задаёт начальное состояние как nullptr, выставляет size в ноль.
\end{enumerate}

Деструктор не имеется.

\subsubsection*{TAhoCorasickNode.h}

Переменные-члены:
\begin{enumerate}
	\item TLinksMap links - набор ребёр для данного узла, где TLinksMap - это std::map;
	\item TAKNode*  fail - суффиксная ссылка, где TAKNode - класс, являющийся узлом дерева бора;
	\item TAKNode*  term - терминальная ссылка;
	\item int out - номер образца, если узел терминальный;
	\item int deep - длина образца, если узел терминальный;
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Публичные методы:
	\begin{enumerate}
		\item GetLink(unsigned long long int) const - возвращает ссылку на узел, к которому можно добраться за счёт заданного символа;
		\item IsTerminal() const - проверяет, является ли узел терминальным.
	\end{enumerate}
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TAKNode() - задаёт ссылки, как nullptr, присваивает deep и out значения по умолчанию;
	\item TAKNode(TAKNode*) - аналогично конструктору выше. Только присваивает заданную суффиксную ссылку.
\end{enumerate}

Деструктор не имеется.

\subsection*{Дневник отладки}


\subsection*{Тест производительности}


\subsection*{Выводы}
Очевидно, алгоритм проходит по тексту за линейное время, т.е. $O(N)$, где N - число символов в строке.

Данный алгоритм отлично себя проявляет, когда имеет дело со множеством образцов. Очевидно, что если в нём будет только один образец, то ничего путного не выйдет. Ведь смысл этого алгоритма состоит в том, чтобы находить множество образцов.

\end{document}