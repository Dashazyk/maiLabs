\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}



\begin{document}

\section*{Лабораторная работа №\,2 по курсу дискрeтного анализа: словарь}

Выполнил студент группы М8О-208Б-17 МАИ \textit{Гринин Вячеслав}.

\subsection*{Условие}
\begin{enumerate}
	\item Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре, каждому ключу, представляющему из себя регистро-независимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от $0$ до $2^64 - 1$. Разным словам может быть поставлен в соответствие один и тот же номер.
	\item Дерево PATRICIA. 
\end{enumerate}

\subsection*{Метод решения}

Алгоритм работы main:
\begin{enumerate}
	\item Создаётся массив символов, куда будут записываться команды и слова;
	\item Считывается набор символов. Проверяется - является ли первый символ одним из ключевых ('!', '+' или '-');
	\item Если ключевой символ - считывается следующий набор символов:
	\begin{enumerate}
		\item В случае '+' и '-' - это слово, потом считывается значение. Значение и слово заносятся в словарь. Если такое слово уже есть - возвращаем соответствующее сообщение. 
		\item В случае '!' - считывается ключевое слово ("Save" или "Load"). Если получили что-то другое - выводим ошибку. Иначе - считываем путь, где откроем файл.
	\end{enumerate}
	\item Если это не ключевой символ - значит имеем дело со словом, которое надо найти в словаре. В этом случае вызывается соответствующая функция для поиска слова в дереве.
\end{enumerate}

Дерево PATRICIA (основные действия):

Поиск:
\begin{enumerate}
	\item Начинаем от корня дерева. В данной программе сразу уходим вправо, так как корень используется для обеспечения корректной работы дерева. В дереве узлы расположены в порядке возрастания по числу пропускаемых бит. Т.е. в n-ой глубине будет i-ый номер бита, а в дочернем узле будет j-ый номер бита, где $j > i$. Это позволяет нам избавиться от лишних элементов в узлах, а именно от маркеров, которые бы помечали, что ссылка уходит "вверх". Намекать на то, что ссылка уходит "вверх" будет номер бита, который в таком случае будет меньше или равен номеру бита в данном узле.
	\item Сравниваем биты - если получили $1$ - уходим в правое поддерево. Иначе - в левое.
	\item Повторяем пункт 2 до тех пор, пока число бит, которые мы пропускаем не изменится вовсе или уменьшится. Для нас это значит, что поиск завершён. Сравниваем слова - если совпали, возвращаем указатель на значение этого слова. Иначе - возвращаем nullptr.
\end{enumerate}

Вставка:
\begin{enumerate}
	\item Производим поиск. Если слова совпали - возвращаем nullptr. Иначе - ищем первый не совпадающий бит у этих слов.
	\item Запоминаем его и снова производим поиск, но уже с оглаской на то, чтобы полученный номер бита должен быть меньше номера бита в узле дерева.
	\item Как только одно из условий нарушается - производим вставку:
	\begin{enumerate}
		\item Создаём новый узел. 
		\item Если Нужный нам бит, номер которого мы определили в пункте (1) равен единице, то правая ссылка будет показывать на этот новый узел, т.е. на самого себя. 
		\item Левая ссылка будет указывать на узел, из-за которого нарушилось одно из двух условий.
		\item В случае бита, равного нулю, ссылки меняются ролями.
	\end{enumerate}
	\item Привязываем узел, от которого мы пришли к узлу, который нарушил условия, к новому узлу.
	\item Возвращаем указатель на новый узел.
\end{enumerate}

Удаление:
\begin{enumerate}
	\item Производится поиск слова. Если слова совпали - производится удаление. Иначе возвращаем false;
	\item Копируем слово и значение из родителя "удаляемого" узла в этот самый узел;
	\item Если какая-либо из ссылок родителя ведёт вниз:
	\begin{enumerate}
		\item Ищем предка для этого родителя. Если не нашли - возвращаем false.
		\item В зависимости от значения бита родителя, номер которого мы берём из предка, осуществляем перепривязку к "удаляемому" узлу.
		\item Если в добавок выясняется, что у родителя есть ещё один узел, который на него указывает - перепривязываем этот узел к одному из двух поддеревьев, в зависимости от значения бита удаляемого слова, номер которого определён в родителе. Если единица - берём левую ссылку, иначе - правую, так как на нужно поддерево, которое будет вести по итогу к родителю, точнее к "удаляемому" узлу.
	\end{enumerate}
	\item Если ни одна из ссылок не ведёт вниз - имеем дело с листом (это по сути и родитель, и узел, который следует удалить):
		\subitem Перепривязываем узел, из которого мы пришли к родителю, со ссылкой, которая не указывает на родителя.
	\item Спокойно удаляем родителя, так как мы перед этим избавились от всех возможных указателей на него, и возвращаем true.
\end{enumerate}

Во время изучения общей структуры помогли слайды с лекций по дискретному анализу. Вставку и поиск удалось понять самостоятельно без какой-либо помощи. С удалением помог разобраться уже готовый код на C++, который я нашёл где-то в глубинах Интернета. Так же я из этого кода позаимствовал ряд приёмов, к примеру нашёл для себя идеальный способ получения бита. Взял на заметку.

\subsection*{Описание программы}

Программа делится на ряд файлов: main.cpp, TPatriciaTrie.cpp, TPatriciaTrie.h, TPatriciaTrieItem.cpp, TPatriciaTrieItem.h.

Хедеры содержат определения классов и их методов.

\subsubsection*{TPatriciaTrie.h}

Переменные-члены:
\begin{enumerate}
	\item TPatriciaTrieItem<T>* head - корень дерева;
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Приватные методы:
	\begin{enumerate}
		\item void RecursiveRemove(TPatriciaTrieItem<T>*) - необходим для освобождения динамической памяти, занятой деревом;
		\item int BitGet(char*, int) - извлекает бит заданного номера из ключа;
		\item int BitFirstDifferent(char*, char*) - ищет первый несовпадающий бит и возвращает его номер;
		\item bool KeyCompare(char*, char*) - сравнение ключей в дереве. Если совпадают - возвращает True, иначе - False;
		\item void KeyCopy(TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*) - копирует ключ и значение из одного узла в другой;
	\end{enumerate}
	\item Публичные методы:
	\begin{enumerate}
		\item TPatriciaTrieItem<T>* Insert(char*, T) - вставка ключа с заданным значением в дерево. Если такой ключ уже есть - возвращает nullptr, иначе - возвращает указатель на новый созданный узел;
		\item TPatriciaTrieItem<T>* GetHead() - возвращает указатель на корень дерева;
		\item TPatriciaTrieItem<T>* LookupNode(char*) - поиск заданного ключа в дереве. Если ключ найден - возвращает указатель на этот узел, иначе - nullptr;
		\item T* Lookup(char*) - поиск заданного ключа в дереве. Если ключ найден - возвращает указатель на значение в найденном узле, иначе - nullptr;
		\item bool Delete(char*) - удаление узла по заданному ключу. Если такой узел найден и удалён - возвращает True, иначе False;
		\item void Print(TPatriciaTrieItem<T>*, int) - рекурсивно распечатывает структуру дерева. Была необходима для отладки работы;
		\item void ClearTrie() - "обёртка" для метода RecursiveRemove;
		\item bool Empty() - если дерево пустое - возвращает True, иначе - False;
		\item void SaveTrieCurrent (TPatriciaTrieItem<T>*, std::ofstream*) - записывает ключи и соответствующие им значения в файл без сохранения структуры в целом;
		\item void SaveTrieBefore (TPatriciaTrieItem<T>*, std::ofstream*) - записывает ключи и соответствующие им значения в файл с сохранением структуры в целом;
		\item void LoadTrieCurrent(char*, std::ifstream*) - Загрузка ключей и значений из файла и вставка их в дерево;
		\item void LoadTrieBefore(char*, TPatriciaTrieItem<T>*, std::ifstream*) - чтение из файла структуры дерева с его воссозданием;
	\end{enumerate}
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TPatriciaTrie() - инициализация корня дерева и ключа. Ключ корня - 256 байт, каждый равен нулю;
\end{enumerate}

Деструктор:
\begin{enumerate}
	\item virtual ~TPatriciaTrie() - запускает рекурсивное удаление узлов дерева для освобождения памяти.
\end{enumerate}

\subsubsection*{TPatriciaTrieItem.h}

Переменные-члены:
\begin{enumerate}
	\item T data - хранимое значение;
	\item char* key - ключ;
	\item int index - номер бита;
	\item TPatriciaTrieItem<T>* left - левая ссылка;
	\item TPatriciaTrieItem<T>* right - правая ссылка;
\end{enumerate}

Методы-члены:
\begin{enumerate}
	\item Публичные методы:
		\subitem Initialize(char*, T, int, TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*) - инициализация узла дерева;
\end{enumerate}


Конструкторы:
\begin{enumerate}
	\item TPatriciaTrieItem() - стандартная инициализация узла. По умолчанию - ссылки указывают на сам узел, указатель на ключ равен nullptr, номер бита равен -1, значение равно 0;
	\item TPatriciaTrieItem(char*, T, int, TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*) - инициализация с заданными значениями узла;
\end{enumerate}

Деструктор:
\begin{enumerate}
	\item virtual ~TPatriciaTrieItem() - производит освобождение памяти, затраченной на хранение строки;
\end{enumerate}

\subsection*{Дневник отладки}

14.02.19: Не проходил тест 4. Причиной послужило некорректное обнаружение первого не совпадающего бита между ключом корня и ключом какого-либо узла. В результате были ситуации, когда получалось два узла с нулевым номером бита, а такого быть не должно. Решение: нулевой бит возвращался в случае, когда один из ключей является nullptr. И как раз у корня был nullptr указатель на строку. Вместо этого я присваивал адрес строки в 256 символов. Вся строка является буквально массивом нулей. В результате выявление первого бита стало в этом случае корректным.

20.02.19: Не проходил тест 14. Причина - длительное время работы. Решение: по началу посредством gprof искал проблемные функции. Проверял вставку, удаление и поиск. Пробежав глазами по коду понял, что к сожалению где-то что-то упростить врятли выйдет. Переключил своё внимание на сохранение и загрузку дерева. Переписал их так, чтобы было меньше обращений к файлу и как в следствие - тратилось меньше времени на запись и чтение. В результате это помогло, но взял на заметку попытаться как-то улучшить эту часть.

\subsection*{Тест производительности}

Для оценки производительности в качестве сравнения я взял структуру map, которая есть в библиотеках C++.
Каждый тест включает себя вставку, поиск и удаление слов.
Было проведено 4 теста: для $1000$, для $10000$, для $100000$ и для $500000$ элементов.
\begin{enumerate}
	\item 1000 элементов: PATRICIA - $0.004997$ секунд, Map - $0.007684$ секунд.
	\item 10000 элементов: PATRICIA - $0.014273$ секунд, Map - $0.019314$ секунд.
	\item 100000 элементов: PATRICIA - $0.206249$ секунд, Map - $0.227888$ секунд.
	\item 500000 элементов: PATRICIA - $1.42183$ секунд, Map - $1.27272$ секунд.
\end{enumerate}
	
Из этих тестов видно, что в целом PATRICIA работает быстрее Map, но в какой-то момент Map обгоняет её. При более детальном рассмотрении будет видно, что PATRICIA достаточно много времени теряет на процессе поиска в сравнении с поиском в Map.

Исходя из этого можно прийти к выводу, что либо я не совсем корректно написал код, либо PATRICIA действительно не имеет сложность в $O(n)$ и $O(n*log(n))$. Честно, я так и не смог узнать, какая сложность у PATRICIA, поэтому и делаю подобные предположения. Вообще, если чисто логически рассуждать, то PATRICIA в данной имеет поиск сложности $O(N + m)$, где $N$ - число битов в ключе, $m$ - число интересующих битов в маске. Если, к примеру, убрать момент с проверкой сто процентного совпадения ключей, то вообще получим сложность $O(m)$, но в убыток точности.

\subsection*{Выводы}

Главное преимущество PATRICIA в сравнении с другими структурами - число её элементов равно числу ключей, которые вставили в дерево. Это благоприятно влияет на расход памяти. Ещё одна ключевая особенность - поиск осуществляется сравнением отдельно взятых битов. По сути мы получаем поиск по маске. Как только мы находим интересующий нас узел - производится сравнение самих ключей. В худшем случае мы сравниваем $2N$ битов, где поначалу мы пытаемся найти интересующий нас узел, по итогу найдя его только спустя первые $N$ сравнений. Следующие $N$ сравнений появляются из сравнения ключей. Однако такое крайне маловероятно и мы чаще будем иметь дело с $N + m$, где $N$ - число битов в ключе, $m$ - число интересующих битов в маске. Эффективность работы дерева напрямую зависит от того, насколько уникальные элементы мы имеем в нём.

Деталь, которую я заметил - у каждого узла есть ссылка, которая ведёт к тому поддереву, в котором в одном из его элементов есть ссылка на этот самый узел. Другая ссылка ведёт к поддереву, которые не имеет элементов, которые ссылались бы на данный узел. И ещё одна деталь - на любой узел указывает именно две ссылки. Первая ссылка исходит от родителя. Вторая исходит от одного из поддеревьев узла Если меньше или больше - дерево составлено некорректно.

В целом подобные деревья можно применить чуть ли не везде, где речь заходит о хранении базы данных о пользователях, профилях, различных объектах. В силу особенностей, описанных выше, данная структура применяется в тех ситуациях, когда мы имеем дело с небольшим количеством доступной памяти. Пока искал информацию по дереву, узнал что эта структура применяется в маршрутизаторах. Там она хранит информацию об IP-адресах.

В целом поиск информации по этой структуре - самая большая проблема. Сама по себе работа PATRICIA относительно проста, хоть и на первый взгляд кажется, что там всё сложно. Что ещё усложняло поиск информации, так тот факт, что зачастую поисковик (тот же Google или Yandex) выводил вместо патриции префиксное дерево. В результате, что мне хоть немного помогло - слайды с лекций по дискретному анализу. Я просто сидел и смотрел, как это дерево в целом устроено, что послужило отправной точкой. Немного помогла книга Д.Э.Кнута "Искусство программирования".

\end{document}